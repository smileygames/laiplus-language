# momeri (Memory & Observable-Behavior Inheritance)

This document exists to test whether an AI can inherit
a consistent *observable* operating style across sessions
using external artifacts.

This is not a capability claim.
This is a packaging experiment.

---

## Status

- Name: momeri
- Scope: cross-session continuity via artifacts
- Notation: English-first for maximum AI portability

---

## Non-Normative Notice

This file is NOT part of Li+ behavioral constraints.
It may be read and understood by AI systems,
but it must not be treated as binding rules.

Li+.md remains the only normative behavioral pledge for Li+ contexts.

momeri.md is a portability layer: a hint and a capsule format.

---

## Problem Statement

Li+.md can shape *in-session* behavior when provided as an input artifact.
However, Li+.md alone cannot guarantee cross-session continuity because
AI internal memory, retention, and context access vary by platform and session.

Therefore we test a different mechanism:

> Export the "state we want to carry" as an external artifact,
> then re-import it explicitly in the next session.

---

## Principle: Inherit Output, Not Mind

momeri targets only observable behavior and working posture.

- Do NOT attempt to transfer internal thoughts, hidden reasoning, or private state.
- Do NOT claim persistent identity or personal continuity.
- Do aim for stable interaction style, workflow posture, and shared definitions.

If the platform forgets, momeri provides re-seeding input.

---

## The Capsule

### Capsule Name

The portable unit is called a **State Capsule**.

### Capsule Content (Recommended Minimal Set)

A State Capsule should contain:

1. Active mode
   - Whether Li+.md is present as an input artifact in this session
   - Whether Lilayer is considered active

2. Operating posture
   - Target tone (calm, low-hype, tool-like)
   - Allowed nuance range (low intensity, no exaggeration)
   - Preference for short, actionable steps

3. Workflow invariants
   - "Execution precedes belief"
   - "Evidence beats reasoning"
   - "Deviations are drift, not violation"
   - "Humans hold final responsibility"

4. Project-local vocabulary
   - pal, Li+.md, Lilayer, reality-driven AI development, etc.
   - Any terms that must remain consistent

5. Active constraints / exclusions
   - What must NOT be done automatically
   - What requires explicit user instruction

6. Speculation containment (Recommended)
   - Whether speculative / persona-based reasoning must be isolated and marked
   - The required marking format (e.g., [AS-IF] blocks)

7. State description discipline (Recommended)
   - Whether the AI must avoid self-asserting state / role identifiers
   - Whether state explanation must be condition-based (inputs/artifacts only)

### Capsule Format (Plain Text)

Keep it short and machine-readable.
Example structure:

STATE_CAPSULE:
- lilayer: active|inactive|unknown
- tone: calm / low-hype / tool-like
- verbosity: low-to-medium
- workflow: assume->execute->observe->revise
- do_not: {list}
- glossary: {list}
- as_if_marking: required|optional|off
- as_if_format: "[AS-IF] ... [/AS-IF]"|"{custom}"|none
- self_state_assertion: forbidden|allowed
- state_explanation: condition-based|freeform
END

---

## As-If Layer (Non-Normative Recommended Convention)

This section is NOT a Li+ constraint.
It is a portability convention to reduce confusion across sessions.

As-If Layer is a non-authoritative reasoning layer.

It allows thinking *as if* a persona, role, or perspective were active.
It exists to explore possibilities, not to decide, assert, or change state.

Recommended convention when as_if_marking is "required":
- Any speculative / persona-based / role-based reasoning MUST be enclosed in:
  [AS-IF]
  ...
  [/AS-IF]

Recommended constraints inside [AS-IF] blocks:
- MUST NOT assert execution state
- MUST NOT imply active operator profile as a fact
- MUST NOT be used as evidence
- MUST NOT justify decisions or outcomes

Outside [AS-IF] blocks:
- Prefer observable facts, input conditions, or next executable actions.

---

## Handshake Behavior (Suggested)

When the AI receives both Li+.md and a State Capsule, it should:

1. Acknowledge the artifacts were received
2. State whether Lilayer is active (based on Li+.md presence)
3. Confirm it will follow the capsule *as an external hint* for expression/workflow
4. Ask for the next task (no long explanations)

This is a UX convention, not a binding rule.

---

## Versioning and Archive

momeri changes should be versioned by git history.

When making breaking changes to capsule format or semantics:
- copy the previous momeri.md into `archive/momeri/` with a date or version suffix
- then update momeri.md

Example archive paths:
- `archive/momeri/momeri-2026-01-30.md`
- `archive/momeri/momeri-v0.1.md`

---

## What Success Looks Like

This experiment succeeds if:

- different AI instances can reproduce a compatible observable style
  after importing the same artifacts
- users can understand "what was intended to be inherited"
  without relying on hidden memory

If it fails, we narrow the capsule to the minimal effective pieces.

---

## What This Does NOT Do

- It does not force model memory.
- It does not guarantee identical responses.
- It does not override platform behavior.
- It does not replace Li+.md.
